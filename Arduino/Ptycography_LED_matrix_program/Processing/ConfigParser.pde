/**
 * ConfigParser.pde
 * 
 * This Processing script parses the Arduino C/C++ header file (PtycographyConfig.h)
 * and automatically generates the Java configuration class (PtycographyConfig.java).
 * 
 * It extracts constants from the header file to ensure consistency between
 * Arduino and Processing code.
 */

// The folder containing this Processing sketch
File sketchFolder;

// Function to parse the Arduino configuration header and generate the Java class
void parseArduinoConfig() {
  // Get the path to the Arduino configuration file
  sketchFolder = new File(sketchPath(""));
  File arduinoConfigFile = new File(sketchFolder.getParentFile(), "libraries/PtycographyConfig.h");
  File javaConfigFile = new File(sketchFolder, "PtycographyConfig.java");
  
  if (!arduinoConfigFile.exists()) {
    println("ERROR: Arduino configuration file not found at: " + arduinoConfigFile.getAbsolutePath());
    return;
  }
  
  println("Parsing Arduino configuration from: " + arduinoConfigFile.getAbsolutePath());
  println("Will generate Java config at: " + javaConfigFile.getAbsolutePath());
  
  // Read the Arduino configuration file
  String[] arduinoConfigLines = loadStrings(arduinoConfigFile.getAbsolutePath());
  
  // Maps to store the extracted constants and their values
  HashMap<String, String> intConstants = new HashMap<String, String>();
  HashMap<String, String> floatConstants = new HashMap<String, String>();
  HashMap<String, String> charConstants = new HashMap<String, String>();
  
  // Parse the Arduino configuration file
  boolean inProcessingSection = false;
  
  for (String line : arduinoConfigLines) {
    line = line.trim();
    
    // Check for Processing section marker
    if (line.startsWith("#ifndef ARDUINO")) {
      inProcessingSection = true;
      continue;
    } else if (line.startsWith("#endif") && inProcessingSection) {
      inProcessingSection = false;
      continue;
    }
    
    // Skip comments, empty lines, and non-#define lines
    if (line.startsWith("//") || line.isEmpty() || !line.startsWith("#define")) {
      continue;
    }
    
    // We're interested in #define statements in both common and Processing sections
    if (!inProcessingSection || (inProcessingSection && !line.contains("#ifdef"))) {
      // Extract the constant name and value
      String[] parts = line.split("\\s+", 3);
      if (parts.length >= 3) {
        String name = parts[1];
        String value = parts[2].split("//")[0].trim(); // Remove any trailing comments
        
        // Categorize by type
        if (value.matches("\\d+")) {
          // Integer constant
          intConstants.put(name, value);
        } else if (value.matches("\\d+\\.\\d+f?")) {
          // Float constant
          floatConstants.put(name, value.replace("f", "")); // Remove 'f' suffix
        } else if (value.matches("'.'")) {
          // Character constant
          charConstants.put(name, value);
        }
      }
    }
  }
  
  // Generate the Java configuration class
  generateJavaConfigClass(javaConfigFile, intConstants, floatConstants, charConstants);
  
  println("Configuration parsing complete!");
  println("Found " + intConstants.size() + " integer constants");
  println("Found " + floatConstants.size() + " float constants");
  println("Found " + charConstants.size() + " character constants");
}

// Function to generate the Java configuration class
void generateJavaConfigClass(File outputFile, HashMap<String, String> intConstants, 
                            HashMap<String, String> floatConstants, 
                            HashMap<String, String> charConstants) {
  // Create the output StringBuilder
  StringBuilder output = new StringBuilder();
  
  // Add class header
  output.append("/**\n");
  output.append(" * PtycographyConfig.java\n");
  output.append(" * \n");
  output.append(" * AUTO-GENERATED Java version of the configuration file for Processing\n");
  output.append(" * Generated by ConfigParser.pde - DO NOT EDIT DIRECTLY!\n");
  output.append(" * \n");
  output.append(" * This file is automatically generated from the C/C++ header file\n");
  output.append(" * (PtycographyConfig.h) to ensure consistency between Arduino and Processing.\n");
  output.append(" */\n\n");
  output.append("public class PtycographyConfig {\n");
  
  // Add integer constants
  for (Map.Entry<String, String> entry : intConstants.entrySet()) {
    output.append("  public static final int " + entry.getKey() + " = " + entry.getValue() + ";\n");
  }
  
  // Add float constants
  for (Map.Entry<String, String> entry : floatConstants.entrySet()) {
    output.append("  public static final float " + entry.getKey() + " = " + entry.getValue() + "f;\n");
  }
  
  // Add character constants
  for (Map.Entry<String, String> entry : charConstants.entrySet()) {
    output.append("  public static final char " + entry.getKey() + " = " + entry.getValue() + ";\n");
  }
  
  // Add static block for any initialization code
  output.append("\n  static {\n");
  output.append("    // Static initialization code if needed\n");
  output.append("  }\n");
  
  // Close the class
  output.append("}\n");
  
  // Write the output to the file
  saveStrings(outputFile.getAbsolutePath(), new String[] { output.toString() });
  println("Java configuration class written to: " + outputFile.getAbsolutePath());
}

// Function to be called from the main sketch to regenerate the config
void regenerateConfig() {
  println("Starting configuration regeneration...");
  parseArduinoConfig();
}